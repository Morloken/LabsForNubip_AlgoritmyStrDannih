#include <iostream> 
#include <vector> // для роботи з динамічними масивами (векторами)
#include <windows.h> 
#include <climits> // для роботи з константами, такими як INT_MAX

using namespace std; 

const int V = 8; // Оголошення константи V, яка задає кількість вершин у графі

// Функція для відновлення шляху між двома вершинами
vector<int> reconstructPath(vector<vector<int>>& next, int u, int v) {
    if (next[u][v] == -1) { // Якщо немає шляху між u та v
        return {}; // Повертаємо порожній вектор, що означає відсутність шляху
    }
    vector<int> path = { u + 1 }; // Ініціалізуємо шлях, додаючи початкову вершину (u + 1 для відображення нумерації від 1)
    while (u != v) { // Поки не досягли кінцевої вершини v
        u = next[u][v]; // Оновлюємо u на наступну вершину на шляху до v
        path.push_back(u + 1); // Додаємо вершину до шляху
    }
    return path; // Повертаємо шлях
}

// Алгоритм Флойда-Воршелла для знаходження найкоротших шляхів і відновлення шляху
void floydWarshallWithPathReconstruction(int graph[V][V]) {
    vector<vector<int>> dist(V, vector<int>(V, INT_MAX)); // Ініціалізація матриці відстаней INT_MAX, що позначає відсутність шляху
    vector<vector<int>> next(V, vector<int>(V, -1)); // Ініціалізація матриці наступних вершин 
                                                    // для відновлення шляху (-1 означає відсутність шляху)

    // Ініціалізація матриць `dist` та `next`
    for (int i = 0; i < V; i++) { // Проходимо всі вершини
        for (int j = 0; j < V; j++) { // Проходимо всі вершини для кожної вершини i
            if (graph[i][j] != 0) { // Якщо є шлях від i до j
                dist[i][j] = graph[i][j]; // Ініціалізуємо відстань значенням з graph
                next[i][j] = j; // Зберігаємо j як наступну вершину для відновлення шляху
            }
        }
        dist[i][i] = 0; // Відстань від вершини до самої себе дорівнює 0
        next[i][i] = i; // Наступна вершина для шляху від вершини до себе - сама вершина
    }

    // Основний цикл алгоритму Флойда-Воршелла
    for (int k = 0; k < V; k++) { // Зовнішній цикл по всіх вершинах як проміжних вершин k
        for (int i = 0; i < V; i++) { // Цикл по всіх можливих початкових вершинах i
            for (int j = 0; j < V; j++) { // Цикл по всіх можливих кінцевих вершинах j
                if (dist[i][k] != INT_MAX && dist[k][j] != INT_MAX && dist[i][k] + dist[k][j] < dist[i][j]) {
                    // Якщо шлях i -> k -> j коротший за поточний шлях i -> j, то
                    dist[i][j] = dist[i][k] + dist[k][j]; // Оновлюємо мінімальну відстань між i та j
                    next[i][j] = next[i][k]; // Оновлюємо наступну вершину на шляху від i до j
                }
            }
        }
    }// FLOYD MARSHALL -------------------------         END
/*
Алгоритм проходить через всі можливі проміжні вершини k,
які можуть бути на шляху від вершини i до вершини j. 

Три вкладені цикли дозволяють перебрати всі можливі комбінації вершин:
Для кожної вершини k перевіряється, чи можна скоротити шлях від i до j, пройшовши через k.

Якщо dist[i][j] (прямий шлях від i до j) більше, ніж сума шляхів dist[i][k] + dist[k][j], то:
dist[i][j] оновлюється, щоб відобразити новий, коротший шлях.
next[i][j] оновлюється, вказуючи, що для переходу від i до j потрібно спочатку рухатися до next[i][k].

Після завершення алгоритму користувач може ввести початкову та кінцеву вершини. 

Програма:
Перевіряє, чи існує шлях між обраними вершинами.
Якщо шлях існує, викликається функція reconstructPath,
яка використовує матрицю next для побудови послідовності
вершин на найкоротшому шляху від початкової до кінцевої.

*/

    // Запит у користувача для вибору вершин
    int src/*start*/, dest/*finish*/;
    cout << "Введіть номер початкової вершини: "; // Запит на введення початкової вершини
    cin >> src; 
    cout << "Введіть номер кінцевої вершини: "; // Запит на введення кінцевої вершини
    cin >> dest;
    src--; dest--; // Зміщення для перетворення з 1-індексації в 0-індексацію

    // Виведення результатів
    if (dist[src][dest] == INT_MAX) { // Якщо відстань INT_MAX, значить шляху немає
        cout << "Шляху від вершини " << src + 1 << " до вершини " << dest + 1 << " не існує." << endl;
    }
    else {
        cout << "Найкоротший шлях від вершини " << src + 1 << " до вершини " << dest + 1 << " дорівнює " << dist[src][dest] << endl;

        vector<int> path = reconstructPath(next, src, dest); // Відновлюємо шлях
        cout << "Шлях: ";
        for (int v : path) { // Виводимо всі вершини шляху
            cout << v << " ";
        }
        cout << endl;
    }
}

int main() {
    SetConsoleOutputCP(1251); 
    SetConsoleCP(1251);
    setlocale(LC_ALL, "");

    int graph[V][V] = { // Визначення графу (матриця суміжності)
        {0, 0, 0, 0, 0, 9, 0, 14},  // Ребра для вершини 1
        {13, 0, 4, 0, 0, 0, 16, 0}, // Ребра для вершини 2
        {0, 4, 0, 0, 0, 12, 0, 0},  // Ребра для вершини 3
        {0, 0, 0, 0, 8, 0, 0, 13},  // Ребра для вершини 4
        {0, 0, 0, 8, 0, 0, 13, 0},  // Ребра для вершини 5
        {9, 0, 12, 0, 5, 0, 0, 0},  // Ребра для вершини 6
        {0, 16, 0, 0, 13, 0, 0, 0}, // Ребра для вершини 7
        {0, 0, 0, 13, 0, 0, 0, 0}   // Ребра для вершини 8
    };

    floydWarshallWithPathReconstruction(graph); // Викликаємо функцію для знаходження найкоротших шляхів

    return 0; // Завершення програми
}
