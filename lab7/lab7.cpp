/*
Варіант - 10
Текст допомоги для деякої програми організований як лінійний список.
Кожна компонента тексту допомоги містить термін (слово) і текст,
що містить пояснення до цього терміну. 
Скласти програму, яка забезпечує:
• вивід пояснювального тексту для заданого терміну; 
• можливість додавання нових термінів і пояснень.
Програма повинна забезпечувати діалог за допомогою меню і контроль помилок при введенні
*/



#include <iostream>
#include <string>
#include <windows.h>
#include <cctype> // Для функції isalpha
#include <locale> // Для роботи з локалями



using namespace std;

// Структура для елемента списку
struct Node {
    string term; // Термін
    string explanation;  // Пояснення
    Node * next; // Вказівник на наступний елемент у списку
    Node * prev; // Вказівник на попередній елемент списку
};

// Функція для створення нового вузла
Node * createNode(const string & term, const string & explanation) {
    
    Node * newNode = new Node;// Виділення пам'яті для нового вузла типу Node

    // Присвоюю значення терміну новому вузлу
    newNode->term = term;

    // Присвоюю значення пояснення новому вузлу
    newNode->explanation = explanation;

    newNode->next = nullptr;// Ініціалізую вказівник на наступний елемент як nullptr (вузол поки що не зв'язаний з іншим)
    //nullptr - ключове слово, яке представляє нульовий вказівник у сучасному C++.
    // Воно введене в стандарті C++11 для заміни старого NULL

   
    newNode->prev = nullptr; // Ініціалізую вказівник на попередній елемент як nullptr (вузол поки що не зв'язаний з попереднім)

    
    return newNode;// Повертання вказівника на новий вузол
}
/*1. createNode
Опис: Функція створює новий вузол двонаправленого списку.
Вона приймає два аргументи: термін і пояснення. 
Після цього створюється новий об'єкт типу Node, який зберігає ці значення.
Також ініціалізуються вказівники на наступний і
попередній вузли (вони встановлюються в nullptr, оскільки на момент створення вузол ні з ким не зв'язаний).
*/







// Функція для додавання нового елемента в кінець списку ======================================     (1)
void static append(Node * & head, const string & term, const string & explanation) {
    Node * newNode = createNode(term, explanation);
    if (!head) {
        head = newNode;
    }
    else {//якщо список не порожній ,проходимо в його кінець і вже від тої позиції додаємо новий термін
        Node * temp = head;
        while (temp->next) {
            temp = temp->next;//перестрибування на наступний елемент
        }
        temp->next = newNode;
        newNode->prev = temp;
    }
    cout << "Термін '" << term << "' додано до списку.\n";
    //функція не має ретурна, бо виконується циклічно доти, доки успішно не додасть елемент у список.
}
/*2. append
Опис: Ця функція додає новий елемент (вузол) у кінець двонаправленого списку.
Спочатку вона перевіряє, чи список порожній. Якщо список порожній, новий вузол стає першим елементом списку.
Якщо список не порожній, функція проходить через список до кінця і додає новий вузол після останнього елемента.
*/





// Функція для виведення пояснення для заданого терміну =================================================   (2)
void static printExplanation(Node * head, const string& term) {
    Node * temp = head;
    while (temp) {
        if (temp->term == term) {
            cout << "Пояснення для терміну '" << term << "': " << temp->explanation << endl;
            return;
        }
        temp = temp->next;
    }
    cout << "Термін '" << term << "' не знайдено у списку.\n";
}
/*3. printExplanation
Опис: Функція шукає заданий термін у списку та
виводить на екран пояснення до цього терміну. 
Вона проходить через всі елементи списку до тих пір, поки не знайде елемент,
термін якого співпадає із введеним користувачем. 
Якщо термін знайдено, виводиться його пояснення. 
Якщо термін відсутній у списку, виводиться повідомлення, що термін не знайдено.
*/






// Функція для виведення всіх термінів у списку ========================================================   (3)
void static printAllTerms(Node * head) {
    Node * temp = head;
    if (!temp) {
        cout << "Список термінів порожній.\n";
        return;
    }
    cout << "Список термінів:\n";
    while (temp) {
        cout << temp->term << ": " << temp->explanation << endl;
        temp = temp->next;
    }
}
/*4. printAllTerms
Опис: Ця функція виводить на екран всі терміни і їх пояснення,
що зберігаються в двонаправленому списку. 
Вона проходить через кожен елемент списку і виводить його значення (термін і пояснення).
Якщо список порожній, функція виводить повідомлення, що термінів немає.
*/











// Функція для видалення терміну і пояснення з двонаправленого списку =======================================     (4)
void static deleteTerm(Node * & head, const string & term) {
    if (!head) {
        cout << "Список порожній, видаляти нічого.\n";
        return;
    }

    Node * temp = head;

    // Пошук вузла з відповідним терміном
    while (temp && temp->term != term) {
        temp = temp->next;
    }

    if (!temp) {
        cout << "Термін '" << term << "' не знайдено у списку.\n";
        return;
    }

    // Якщо це єдиний вузол у списку
    if (temp == head && !temp->next) {
        head = nullptr;
    }
    // Якщо це перший вузол
    else if (temp == head) {
        head = head->next;
        head->prev = nullptr;
    }
    // Якщо це останній вузол
    else if (!temp->next) {
        temp->prev->next = nullptr;
    }
    // Якщо це вузол десь посередині
    else {
        temp->prev->next = temp->next;
        temp->next->prev = temp->prev;
    }

    delete temp;
    cout << "Термін '" << term << "' було видалено.\n";
}
/*5. deleteTerm
Опис: Ця функція дозволяє видалити елемент (термін і його пояснення) зі списку.
Вона спочатку перевіряє, чи не є список порожнім, а потім шукає термін,
який потрібно видалити. Якщо термін знайдено, функція видаляє його з урахуванням того, 
чи є цей елемент першим, останнім або знаходиться десь посередині. 
Якщо термін не знайдено, виводиться повідомлення про це.
*/

//....................................................................................Checking for the input correction
// Валідація введеного терміну
bool static isValidTerm(const string & term) {
    setlocale(LC_ALL, ""); // Встановлення локалі на основі поточного середовища (для підтримки кирилиці)

    for (char c : term) {
        
        if (!((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || 
            (c >= 'А' && c <= 'Я') || (c >= 'а' && c <= 'я') ||  
            (c == 'Є' || c == 'є' || c == 'І' || c == 'і' || c == 'Ї' || c == 'ї' || c == 'Ґ' || c == 'ґ')) 
            ||  (isdigit(c)) || (c == ' ')) {
            return false;
        }
    }
    return true;
}

// Валідація введеного пояснення
bool static isValidExplanation(const string & explanation) {
    return !explanation.empty(); // Перевіряю, що пояснення не порожнє
}
//...................end




// Головне меню =======================================================================             MENU
void static menu(Node * & head) {

    string choiceInput; // Замість int використовується рядок для введення
    //(перевірка на те, чи є цифрою введений користувачем вибір)


    int choice = -1;//варіант вибору функції з менюшки
    string term, explanation;

    do {
        cout << "\n\n\t    --- Меню ---\n";
        cout << "\t---------**---------\n";
        cout << "1. \tДодати новий термін\n";
        cout << "\t--------------------\n";
        cout << "2. Вивести пояснення для терміну\n";
        cout << "\t--------------------\n";
        cout << "3. \tВивести всі терміни\n";
        cout << "\t--------------------\n";
        cout << "4. \tВидалити термін\n";  // Додано опцію для видалення терміну
        cout << "\t--------------------\n";
        cout << "0. \t       Вийти\n";
        cout << "Ваш вибір: ";


        getline(cin, choiceInput); // Введення рядковим форматом

        // Перевірка, чи введене значення вибору користувача є цифрою
        if (choiceInput.length() == 1 && isdigit(choiceInput[0])) {
            choice = stoi(choiceInput); // Перетворення рядка на число
        }
        else {
            cout << "Неправильний вибір, потрібно ввести цифру. Спробуйте ще раз.\n";
            continue; // Повертаємося до початку циклу для повторного вибору
        }




        switch (choice) {
        case 1:
            cout << "Введіть термін: ";
            getline(cin, term);//команда для зчитування вводу користувача з консолі та запису його в змінну term

            // Перевірка правильності терміну
            if (!isValidTerm(term)) {
                cout << "Термін може містити тільки літери. Спробуйте ще раз.\n";
                break;
            }

            cout << "Введіть пояснення: ";
            getline(cin, explanation);

            // Перевірка правильності пояснення
            if (!isValidExplanation(explanation)) {
                cout << "Пояснення не може бути порожнім. Спробуйте ще раз.\n";
                break;
            }


            append(head, term, explanation);
            break;
        case 2:
            cout << "Введіть термін, для якого потрібне пояснення: ";
            getline(cin, term);
            printExplanation(head, term);
            break;
        case 3:
            printAllTerms(head);
            break;
        case 4:
            cout << "Введіть термін для видалення: ";
            getline(cin, term);
            deleteTerm(head, term);  // Виклик функції видалення
            break;
        case 0:
            cout << "Вихід з програми.\n";
            break;
        default:
            cout << "Неправильний вибір, спробуйте ще раз.\n";
        }
    } while (choice != 0);
}
/*6. menu
Опис: Функція забезпечує взаємодію з користувачем через консольне меню. Вона пропонує кілька опцій:

Додавання нового терміну і пояснення(1).
Виведення пояснення для конкретного терміну(2).
Виведення всіх термінів і їх пояснень(3).
Видалення терміну зі списку(4).
Вихід з програми. Користувач обирає потрібну опцію(0), 
і програма виконує відповідну дію. 
Меню працює у циклі, доки користувач не вибере вихід (опція 0).
*/














int main() { //=========================================================================         MAIN
    SetConsoleOutputCP(1251);
    SetConsoleCP(1251);


    Node * head = nullptr;  // Початково список порожній
    /*head — це вказівник на перший елемент (вузол) списку.
    Він дає стартовий доступ до всіх елементів списку.*/




    menu(head); //головне меню
    return 0;
}




//========================================================================================================================       NOTES FOR CODE
/*
    //nullptr - ключове слово, яке представляє нульовий вказівник у сучасному C++.
    // Воно введене в стандарті C++11 для заміни старого NULL


*/